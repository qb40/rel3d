<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<!--.............................................-->
<!--. Downloaded from Phat Code                 .-->
<!--. http://www.phatcode.net/                  .-->
<!--.............................................-->
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="description" content="A detailed look at vectors and their applications in 3D graphics">
<meta name="keywords" content="A detailed look at vectors and their applications in 3D graphics">
<title>phatcode.net / 3D Series Chapter 3: Vectors by Rel (Richard Eric M. Lope)</title>
<style type="text/css">
<!--
body {font-family:verdana, geneva, helvetica, arial, sans-serif; font-size:x-small; color:#000000; background:#ffffff;}
p, table, td {font-size:x-small; line-height:150%;}
li {line-height:150%; margin-bottom:1em;}
h1 {font-size:large;}
h2 {font-size:medium;}
h3 {font-size:small;}
a:link {color:#0000ff;}
a:visited {color:#0000ff;}
a:active {color:#0000ff;}
a:hover {color:#0000aa;}
.code {font-family:courier new, courier; font-size:x-small; line-height:130%; color:#000000; background-color:#dddddd; padding:10px; margin:15px; border:#000000 solid 2px;}
.border {border: #000000 solid 1px;}
.divide {border: #000000 solid 1px; margin-top:10px; margin-bottom:10px;}
-->
</style>
</head>
<body>
<h1 align="center">3D Series Chapter 3: Vectors</h1>
<h3 align="center">by <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#118;&#105;&#99;&#95;&#118;&#105;&#112;&#101;&#114;&#112;&#104;&#64;&#121;&#97;&#104;&#111;&#111;&#46;&#99;&#111;&#109;">Rel</a> (Richard Eric M. Lope)</h3>
<div class="divide"></div>
<h2>Vectors are cool!!!</h2>

<p>It's almost impossible to do graphics programming without using vectors. Almost all math concerning 3d coding uses
vectors. If you hate vectors, read on and you'll probably love them more than your girlfriend after you've finished
reading this article. ;*)</p>

<h2>What are vectors?</h2>

<p>First off, let me define 2 quantities: The <i>scalar</i> and <i>vector</i> quantities. Okay, scalar quantities are
just values. One example of it is Temperature. You say, "It's 40 degrees Celsius here", and that's it. No sense of
direction. But to define a vector you need a direction or sense. Like when the pilot say's, "We are 40 kilometers
north of Midway". So a scalar quantity is just a value while a vector is a value + direction.</p>

<p>Look at the figure below: The <i>arrow</i> (ray) represents a vector. The "head" is its <i>"sense"</i> (direction is
not applicable here) and the "tail" is its starting point. The distance from head to tail is called its "magnitude".</p>

<p align="center"><img src="vector.png"></p>

<p>In this vector there are 2 components, the X and Y component. X is the horizontal and Y is the vertical component.
Remember that <b>"ALL VECTOR OPERATIONS ARE DONE WITH ITS COMPONENTS."</b></p>

<p>I like to setup my vectors in this TYPE:</p>

<div class="code">
TYPE Vector<br />
&nbsp; &nbsp; x AS SINGLE<br />
&nbsp; &nbsp; y AS SINGLE<br />
END TYPE<br />
</div>

<p><i>The difference between the "sense" and "direction" is that direction is the line the vector is located while sense
can go either way on that line.</i></p>

<p align="center"><img src="sense.png"></p>

<h2>Definitions</h2>

<p><i>*|v| means that |v| is the magnitude of v.</i></p>

<p><i>*Orthogonal vectors are vectors perpendicular to each other. It's sticks up 90 degrees.</i></p>

<p align="center"><img src="orthogonal.png"></p>

<p>To get a vector between 2 points:</p>

<p>2d:</p>

<div class="code">
v = (x2 - x1) + (y2 - y1)<br />
</div>

<p>3d:</p>

<div class="code">
v = (x2 - x1) + (y2 - y1) + (z2 - z1)<br />
</div>

<p>QB code:</p>

<div class="code">
vx = x2 - x1<br />
vy = y2 - y1<br />
vz = z2 - z1<br />
</div>

<p>where: (x2-x1) is the horizontal component and so on.</p>

<p>Vectors are not limited to the cartesian coordinate system. In polar form:</p>

<div class="code">
v = r * theta <br />
</div>

<p align="center"><img src="polarvec.png"></p>

<h2>Resolving a vector by its components</h2>

<p>Suppose a vector v has a magnitude 5 and direction given by Theta = 30 degrees. Where theta is the angle the vector
makes with the positive x-axis. How do we resolve this vectors' components?</p>

<p align="center"><img src="resolve.png"></p>

<p>Remember the Polar to Cartesian conversion?</p>

<div class="code">
v.x = cos(theta)<br />
v.y = sin(theta)<br />
</div>


<p>
Let vx = horizontal component<br />
Let vy = horizontal component<br />
Let Theta = Be the angle</p>

<p>So...</p>
<div class="code">
v.x = |v| * cos(theta)<br />
v.x = 5 * cos(30)<br />
v.x = 4.33<br />
<br />
v.y = |v| * sin(theta)<br />
v.y = 5 * sin(30)<br />
v.y = 2.50<br />
</div>

<p>What I've been showing you is a 2d vector. Making a 3d vector is just adding another component, the Z component.</p>

<div class="code">
TYPE Vector<br />
&nbsp; &nbsp; x AS SINGLE<br />
&nbsp; &nbsp; y AS SINGLE<br />
&nbsp; &nbsp; z AS SINGLE<br />
END TYPE<br />
</div>

<h2>Operations on vectors needed in 3d engines</h2>

<ol>
<h3><li>Scaling a vector(Scalar multiplication)</h3>

<p>Purpose:</p>

<dl><dd>This is used to scale a vector by a scalar value. Needed in the scaling of models and changing the velocity of projectiles.</dd></dl>

<p>Equation:</p>

<dl><dd>
<div class="code">
v = v * scale<br />
</div>
</dd></dl>

<p>QB code:</p>

<dl><dd>
<div class="code">
v.x = v.x * Scale<br />
v.y = v.y * Scale<br />
v.z = v.z * Scale<br />
</div>
</dd></dl>

</li>
<h3><li>Getting the Magnitude(Length) of a vector</h3>

<p>Purpose:</p>

<dl><dd>Used in "Normalizing"(making it a unit vector) a vector. More on this later.</dd></dl>

<p>Equation:</p>

<dl><dd>
<div class="code">
|V| = Sqr(v.x^2 + v.y^2 + v.z^2)<br />
</div>
</dd></dl>

<p>QB code:</p>

<dl><dd>
<div class="code">
Mag! = Sqr(v.x^2 + v.y^2 + v.z^2) <br />
</div>
</dd></dl>

</li>
<h3><li>Normalizing a vector</h3>

<p>Purpose:</p>

<dl><dd>Used in light sourcing, camera transforms, etc. Makes the vector a "unit-vector" that is a vector having a
magnitude of 1. Divides the vector by its length.</dd></dl>

<p>Equation:</p>

<dl><dd>
<div class="code">
&nbsp;v = v<br />
-------<br />
&nbsp; |v|<br />
</div>
</dd></dl>

<p>QB code:</p>

<dl><dd>
<div class="code">
Mag! = Sqr(v.x^2 + v.y^2 + v.z^2) <br />
v.x = v.x / mag!<br />
v.y = v.y / mag!<br />
v.z = v.z / mag!<br />
</div>
</dd></dl>

</li>
<h3><li>The DOT Product</h3>

<p>Purpose:</p>

<dl><dd>Used in many things like lightsourcing and vector projection. Returns the cosine of the angle between any two
vectors (Assuming the vectors are Normalized). A Scalar. The dot product is also called the "Scalar" product.
</dd></dl>

<p>Equation:</p>

<dl><dd>
<div class="code">
v.w = v.x* w.x + v.y* w.y + v.z* w.z <br />
</div>
</dd></dl>

<p>QB code:</p>

<dl><dd>
<div class="code">
Dot! = v.x* w.x + v.y* w.y + v.z* w.z <br />
</div>
</dd></dl>

<p>Fun fact:</p>

<dl><dd><i>* 2 Vectors are orthogonal if their dot product is 0.<br />
Proof: "What is the cosine of 90?"</i></dd></dl>

</li>
<h3><li>The CROSS product</h3>

<p>Purpose:</p>

<dl><dd>Used in lightsourcing, camera transformation, back-face culling, etc. The cross product of 2 vectors returns
another vector that is orthogonal to the plane that has the first 2 vectors. Let's say we have vectors U and F.</dd></dl>

<p>Equation:</p>

<dl><dd>
<div class="code">
U x F = R<br />
</div>
</dd></dl>

<p>QB code:</p>

<dl><dd>
<div class="code">
R.x = U.y * F.z - F.y * U.z<br />
R.y = U.z * F.x - F.z * U.x<br />
R.z = U.x * F.y - F.x * U.y<br />
</div>
</dd></dl>

<p>Fun facts:</p>

<dl><dd><i>* C is the vector orthogonal to A and B.<br />
* C is the NORMAL to the plane that includes A and B. The cross-product of any two vectors can best be remembered by
the CRAMERS RULE on DETERMINANTS.  Thought of it while taking a bath.  I'll tell you when I finish my matrix chapter.<br />
* The cross product is exclusive to 3d and its also called the "Vector" product.</i></dd></dl>

<p align="center"><img src="crossproduct.png"></p>

</li>
<h3><li>Vector Projection</h3>

<p>Purpose:</p>

<dl><dd>Used in resolving the second vector of the camera matrix (Thanks Toshi!). For vectors A and B...</dd></dl>

<p align="center"><img src="vectorprojection.png"></p>

<p>Equation:</p>

<dl><dd>
<div class="code">
U.Z * Z<br />
</div>
</dd></dl>

<p>QB code:</p>

<dl><dd>
<p>Let N = vector projection of U to Z.  The vector parallel to Z.</p>

<div class="code">
T! = Vector.Dot(U, Z)<br />
<br />
N.x = T! * Z.x<br />
N.y = T! * Z.y<br />
N.z = T! * Z.z<br />
</div>
</dd></dl>

</li>
<h3><li>Adding vectors</h3>

<p>Purpose:</p>

<dl><dd>Used in camera and object movements. Anything that you'd want to move relative to your camera. Adding vectors is
just the same as adding their components. Let A and B be vectors in 3d, and C is the sum:</dd></dl>

<p>Equations:</p>

<dl><dd>
<div class="code">
C = A + B <br />
C = (ax + bx) + (ay + by) + (az + bz)<br />
</div>
</dd></dl>

<p>QB code:</p>

<dl><dd>
<div class="code">
c.x = a.x + b.x<br />
c.y = a.y + b.y<br />
c.z = a.z + b.z <br />
</div>
</dd></dl>

</li>
</ol>

<p>Now that Most of the Math is out of the way....</p>

<h2>Applications</h2>

<ol type="I">
<h3><li>WireFraming and Backface culling</h3>

<p>I like to make use of types with my 3d engines. For Polygons:</p>

<div class="code">
TYPE Poly<br />
&nbsp; &nbsp; p1 AS INTEGER<br />
&nbsp; &nbsp; p2 AS INTEGER<br />
&nbsp; &nbsp; p3 AS INTEGER<br />
END TYPE<br />
</div>

<p>P1 is the first vertex, p2 second and p3 third. Let's say you have a nice rotating cube composed of points, looks
spiffy but you want it to be composed of polygons (Triangles) in this case). If we have a cube with vertices:</p>

<div class="code">
Vtx1&nbsp; 50, 50, 50&nbsp; :x,y,z<br />
Vtx2 -50, 50, 50<br />
Vtx3 -50,-50, 50<br />
Vtx4&nbsp; 50,-50, 50<br />
Vtx5&nbsp; 50, 50,-50<br />
Vtx6 -50, 50,-50<br />
Vtx7 -50,-50,-50<br />
Vtx8&nbsp; 50,-50,-50<br />
</div>

<p>What we need are connection points that define a face. The one below is a Quadrilateral face (4 points)</p>

<div class="code">
Face1 1, 2, 3, 4<br />
Face2 2, 6, 7, 3<br />
Face3 6, 5, 8, 7 <br />
Face4 5, 1, 4, 8<br />
Face5 5, 6, 2, 1<br />
Face6 4, 3, 7, 8<br />
</div>

<p>Face1 would have vertex 1, 2, and 3 as its connection vertices.</p>

<p>Now since we want triangles instead of quads, we divide each quad into 2 triangles, which would make 12 faces. It's also
imperative to arrange your points in counter-clockwise or clockwise order so that backface culling would work. In this case
I'm using counter-clockwise.</p>

<p>The following code divide the quads into 2 triangles with vertices arranged in counter-clockise order. Tri(j).idx will
be used for sorting.</p>

<p>QB code:</p>

<div class="code">
j = 1<br />
FOR i = 1 TO 6<br />
&nbsp; &nbsp; READ p1, p2, p3, p4&nbsp; 'Reads the face (Quad)<br />
&nbsp; &nbsp; Tri(j).p1 = p1<br />
&nbsp; &nbsp; Tri(j).p2 = p2<br />
&nbsp; &nbsp; Tri(j).p3 = p4<br />
&nbsp; &nbsp; Tri(j).idx = j<br />
&nbsp; &nbsp; j = j + 1<br />
&nbsp; &nbsp; Tri(j).p1 = p2<br />
&nbsp; &nbsp; Tri(j).p2 = p3<br />
&nbsp; &nbsp; Tri(j).p3 = p4<br />
&nbsp; &nbsp; Tri(j).idx = j<br />
&nbsp; &nbsp; j = j + 1<br />
NEXT i<br />
</div>

<p>To render the cube without backface culling, here's the pseudocode:</p>

<div class="code">
1. Do<br />
2. Rotatepoints<br />
3. Project points<br />
4. Sort (Not needed for cubes and other simple polyhedrons)<br />
5. Get Triangles' projected coords<br />
&nbsp; &nbsp; &nbsp;ie. <br />
&nbsp; &nbsp; &nbsp; &nbsp;x1 = Model(Tri(i).P1).ScreenX<br />
&nbsp; &nbsp; &nbsp; &nbsp;y1 = Model(Tri(i).P1).ScreenY<br />
&nbsp; &nbsp; &nbsp; &nbsp;x2 = Model(Tri(i).P2).ScreenX<br />
&nbsp; &nbsp; &nbsp; &nbsp;y2 = Model(Tri(i).P2).ScreenY<br />
&nbsp; &nbsp; &nbsp; &nbsp;x3 = Model(Tri(i).P3).ScreenX<br />
&nbsp; &nbsp; &nbsp; &nbsp;y3 = Model(Tri(i).P3).ScreenY<br />
6. Draw<br />
&nbsp; &nbsp; &nbsp; &nbsp;Tri x1,y1,x2,y2,x3,y3,color<br />
</div>

<h3>Backface Culling</h3>

<p>Backface culling is also called <i>"hidden face removal"</i>. In essense, it's a way to speed up your routines by NOT
showing a polygon if it's not facing towards you. But how do we know what face of the polygon is the "right" face? Let's
take a CD as an example, there are 2 sides to a particular CD. One side that the data is to be written and the other side
where the label is printed. What if we decide that the Label-side should be the right side? How do we do it? Well it
turns out that the answer is our well loved NORMAL. :*) But for that to work, we should *sequentially* arrange our
vertices in counter or clockwise order.</p>

<p>If you arranged your polys' vertices in counter-clockwise order as most 3d modelers do, you just get the projected
z-normal of the poly and check if its greater than(>)0. If it is, then draw triangle. Of course if you arranged the
vertices in clockwise order, then the poly is facing us when the Z-normal is <0.</p>

<p><b>Counter-Clockwise arrangement of vertices:</b></p>

<p align="center"><img src="normal.png"></p>

<p><b>Clockwise Arrangement of vertices:</b></p>

<p align="center"><img src="normal2.png"></p>

<p>Since we only need the z component of the normal to the poly, we could even use the "projected" coords (2d) to get the
z component!</p>

<p>QB code:</p>

<div class="code">
Znormal = (x2 - x1) * (y1 - Y3) - (y2 - y1) * (x1 - X3)<br />
IF (Znormal &gt; 0) THEN&nbsp; &nbsp;'&gt;0 so vector facing us<br />
&nbsp; &nbsp; Drawpoly x1,y1,x2,y2,x3,y3<br />
END IF<br />
</div>

<p>Here's the example file:<br />
<a href="3dwire.bas" target="_blank">3dwire.bas</a></p>

<h3>Sorting</h3>

<p>There are numerous sorting techniques that I use in my 3d renders here are the most common:</p>

<ol>
<li style="margin-bottom:0em;">Bubble sort (modified)</li>
<li style="margin-bottom:0em;">Shell sort</li>
<li style="margin-bottom:0em;">Quick sort</li>
<li style="margin-bottom:0em;">Blitz sort (PS1 uses this according to Blitz)</li>
</ol>

<p>I won't go about explaining how the sorting algorithms work. I'm here to discuss how to implement it in your engine.
It may not be apparent to you (since you are rotating a simple cube) but you need to sort your polys to make your renders
look right. The idea is to draw the farthest polys first and the nearest last. Before we could go about sorting our polys
we need a new element in our polytype.</p>

<div class="code">
TYPE Poly<br />
&nbsp; &nbsp; p1 AS INTEGER<br />
&nbsp; &nbsp; p2 AS INTEGER<br />
&nbsp; &nbsp; p3 AS INTEGER<br />
&nbsp; &nbsp; idx AS INTEGER<br />
&nbsp; &nbsp; zcenter AS INTEGER<br />
END TYPE<br />
</div>

<p><i>*Idx would be the index we use to sort the polys. We sort via IDX, not by subscript.<br />
*Zcenter is the theoretical center of the polygon. It's a 3d coord (x,y,z)</i></p>

<p>To get the center of any polygon or polyhedra(model),you add all the 3 coordinates and divide it by the number of
vertices (In this case 3).</p>

<p>Since we only want to get the z center:</p>

<div class="code">
Zcenter = Model(Poly(i).p1)).z + Model(Poly(i).p2)).z + Model(Poly(i).p3)).z<br />
Zcenter = Zcenter / 3<br />
</div>

<p><b>Optimization trick:</b></p>

<p>We don't really need to find the *real* Zcenter since all the z values that were added are going to be still sorted
right. Which means... No divide!!!</p>

<p>Now you sort the polys like this:</p>

<div class="code">
FOR i% = LBOUND(Poly) TO UBOUND(Poly)<br />
&nbsp; &nbsp; Poly(i%).zcenter = Model(Poly(i%).p1).Zr + Model(Poly(i%).p2).Zr + Model(Poly(i%).p3).Zr<br />
&nbsp; &nbsp; Poly(i%).idx = i%<br />
NEXT i%<br />
<br />
Shellsort Poly(), Lbound(Poly), UBOUND(Poly)<br />
</div>

<p>To Draw the model, you use the index(Poly.idx)</p>

<div class="code">
FOR i = 1 TO UBOUND(Poly) <br />
&nbsp; &nbsp; j = Poly(i).idx<br />
&nbsp; &nbsp; x1 = Model(Poly(j).p1).scrx&nbsp; 'Get triangles from "projected"<br />
&nbsp; &nbsp; x2 = Model(Poly(j).p2).scrx&nbsp; 'X and Y coords since Znormal<br />
&nbsp; &nbsp; x3 = Model(Poly(j).p3).scrx&nbsp; 'Does not require a Z coord<br />
&nbsp; &nbsp; y1 = Model(Poly(j).p1).scry <br />
&nbsp; &nbsp; y2 = Model(Poly(j).p2).scry <br />
&nbsp; &nbsp; y3 = Model(Poly(j).p3).scry<br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; 'Use the Znormal,the Ray perpendicular(Orthogonal) to the<br />
&nbsp; &nbsp; &nbsp; &nbsp; 'Screen defined by the Triangle (X1,Y1,X2,Y2,X3,Y3)<br />
&nbsp; &nbsp; &nbsp; &nbsp; 'if Less(&gt;) 0 then its facing in the opposite direction so<br />
&nbsp; &nbsp; &nbsp; &nbsp; 'don't plot. If &lt;0 then its facing towards you so Plot.<br />
<br />
&nbsp; &nbsp; Znormal = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)<br />
&nbsp; &nbsp; IF Znormal &lt; 0 THEN<br />
&nbsp; &nbsp; &nbsp; &nbsp; DrawTri x1, y1, x2, y2, x3, y3<br />
&nbsp; &nbsp; END IF<br />
NEXT i<br />
</div>

<p>Here's a working example:<br />
<a href="sorting.bas" target="_blank">sorting.bas</a></p>

</li>
<h3><li>Spherical and cylindrical coordinate systems</h3>

<p>These 2 systems are extentions of the polar coordinate system. Where polar is 2d these 2 are 3d. :*)</p>

<ol type="a">
<h3><li>Cylindrical coordinate system</h3>

<p>The cylindrical coodinate system is useful if you want to generate models mathematically. Some examples are Helixis,
Cylinders (of course), tunnels or any tube-like model. This system works much like 2d, but with an added z component that
doesn't need and angle. Here's the equations to convert cylindrical to rectangular coordinate system.</p>

<p>Here's the Cylindrical to rectangular coordinate conversion equations. Almost like 2d. Of course this cylinder will
coil on the z axis. To test yourself, why dont you change the equations to coil it on the y axis?</p>

<div class="code">
x = COS(theta)<br />
y = SIN(theta)<br />
z = z<br />
</div>

<p>To generate a cylinder:</p>

<div class="code">
i = 0<br />
z! = zdist * Slices / 2<br />
FOR Slice = 0 TO Slices - 1<br />
&nbsp; &nbsp; FOR Band = 0 TO Bands - 1<br />
&nbsp; &nbsp; &nbsp; &nbsp; Theta! = (2 * PI / Bands) * Band<br />
&nbsp; &nbsp; &nbsp; &nbsp; Model(i).x = radius * COS(Theta!)<br />
&nbsp; &nbsp; &nbsp; &nbsp; Model(i).y = radius * SIN(Theta!)<br />
&nbsp; &nbsp; &nbsp; &nbsp; Model(i).z = -z!<br />
&nbsp; &nbsp; &nbsp; &nbsp; i = i + 1<br />
&nbsp; &nbsp; NEXT Band<br />
&nbsp; &nbsp; z! = z! - zdist<br />
NEXT Slice<br />
</div>

<p>Here's a 9 liner I made using that equation.<br />
<a href="9liner.bas" target="_blank">9liner.bas</a></p>

</li>
<h3><li>Spherical coordinate system</h3>

<p>This is another useful system. It can be used for Torus and Sphere generation. Here's the conversion:</p>

<div class="code">
x = SIN(Phi)* COS(theta)<br />
y = SIN(Phi)* SIN(theta)<br />
z = COS(Phi)<br />
</div>

<p>Where: Theta = Azimuth; Phi = Elevation</p>

<p>To generate a sphere:</p>

<div class="code">
i = 0<br />
FOR SliceLoop = 0 TO Slices - 1<br />
&nbsp; &nbsp; Phi! = PI / Slices * SliceLoop<br />
&nbsp; &nbsp; FOR BandLoop = 0 TO Bands - 1<br />
&nbsp; &nbsp; &nbsp; &nbsp; Theta! = 2 * -PI / Bands * BandLoop<br />
&nbsp; &nbsp; &nbsp; &nbsp; Model(i).x = -INT(radius * SIN(Phi!) * COS(Theta!))<br />
&nbsp; &nbsp; &nbsp; &nbsp; Model(i).y = -INT(radius * SIN(Phi!) * SIN(Theta!))<br />
&nbsp; &nbsp; &nbsp; &nbsp; Model(i).z = -INT(radius * COS(Phi!))<br />
&nbsp; &nbsp; &nbsp; &nbsp; i = i + 1<br />
&nbsp; &nbsp; NEXT BandLoop<br />
NEXT SliceLoop<br />
</div>

<p>Here's a little particle engine using the spherical coordinate system.<br />
<a href="fountain.bas" target="_blank">fountain.bas</a></p>

<p>Here's an example file to generate models using those equations:<br />
<a href="gen3d.bas" target="_blank">gen3d.bas</a></p>

</li>
</ol>
<h3><li>Different Polygon fillers</h3>

<ol type="a">
<h3><li>Flat Filler</h3>

<p>Tired of just wireframe and pixels? After making a wireframe demo, you'd want your objects to be solid. The first
type of fill that I'll be introducing is a flat triangle filler. What?! But I could use PAINT to do that! Well, you
still have to understand how the flat filler works because the gouraud and texture filler will be based on it. ;*)</p>

<p>Now how do we make a flat filler? Let me introduce you first to the idea of <b>LINEAR INTERPOLATION.</b> How does
interpolation work?</p>

<p>Let's say you want to make dot on the screen at location (x1,y1) to (x2,y2) in 10 steps?</p>

<div class="code">
Let A = (x1,y1)<br />
B = (x2,y2)<br />
Steps = 10<br />
<br />
f(x) = (B-A)/Steps<br />
</div>

<p>So....</p>

<div class="code">
dx! = (x2-x1)/steps<br />
dy! = (y2-y1)/Steps<br />
<br />
x! = x1<br />
y! = y1<br />
FOR a = 0 TO steps - 1<br />
&nbsp; &nbsp; PSET (x,y), 15<br />
&nbsp; &nbsp; x! = x! + dx!<br />
&nbsp; &nbsp; y! = y! + dy!<br />
NEXT a <br />
</div>

<p>That's all to there is to interpolation. :*)</p>

<p>Now that we have an idea of what linear interpolation is we could make a flat triangle filler.</p>

<h3>The 3 types of triangles</h3>

<ol type="a">

<b><li><p>Flat Filled</p></b>

<ol>
<li><p>Flat Bottom</p>
<p align="center"><img src="flatbottom.png"></p>
</li>

<li><p>Flat Top</p>
<p align="center"><img src="flattop.png"></p>
</li>

<li><p>Generic Triangle</p>
<p align="center"><img src="dividetri.png"></p>
</li>
</ol>

<p>In both the Flat Top and Flat bottom cases, it's easy to do both triangles as we only need to interpolate A to B and
A to C in Y steps. We draw a horizontal line in between (x1,y) and (x2,y).</p>

<p>The problem lies when we want to draw a generic triangle since we don't know if it's a flat top or flat bottom. But
it turns out that there is an all too easy way to get around with this. Analyzing the generic triangle, we could just
divide the triangle into 2 triangles. One Flat Bottom and One Flat Top!</p>

<p>We draw it with 2 loops. The first loop is to draw the Flat Bottom and the second loop is for the Flat Top.</p>

<p align="center"><img src="generictri.png"></p>

<p>Pseudo Code:</p>

<p>TOP PART ONLY!!!! (FLAT BOTTOM)</p>

<ol>
<li><p>Interpolate <b>a.x</b> and draw each scanline from <b>a.x</b> to <b>b.x</b> in <b>(b.y-a.y)</b> steps.</p>

<div class="code">
ie. a.x = x3 - x1<br />
&nbsp; &nbsp; b.x = y3 - y1<br />
&nbsp; &nbsp; Xstep1! = a.x / b.x<br />
</div>

</li>
<li><p>Interpolate <b>a.x</b> and draw each scanline from <b>a.x</b> to <b>c.x</b> in <b>(c.y-a.y)</b> steps.</p>

<div class="code">
ie. a.x = x1 - x3<br />
&nbsp; &nbsp; c.x = y1 - y3<br />
&nbsp; &nbsp; Xstep3! = a.x / c.x<br />
</div>

</li>
<li><p>Draw each scanline (Horizontal line) from <b>a.y</b> to <b>b.y</b> incrementing <b>y</b> with one in each step, interpolating
<b>LeftX</b> with <b>Xstep1!</b> and <b>RightX</b> with <b>Xstep3!</b>. You've just finished drawing the TOP part of the triangle!!!</p>

</li>
<li><p>Do the same with the bottom-half interpolating from <b>b.x</b> to <b>c.x</b> in <b>b.y</b> steps.</p>

<p>Pseudo Code:</p>

<ol>
<li><p>Sort Vertices</p>

<div class="code">
IF y2 &lt; y1 THEN <br />
&nbsp; &nbsp; SWAP y1, y2<br />
&nbsp; &nbsp; SWAP x1, x2<br />
END IF<br />
IF y3 &lt; y1 THEN<br />
&nbsp; &nbsp; SWAP y3, y1<br />
&nbsp; &nbsp; SWAP x3, x1<br />
END IF<br />
IF y3 &lt; y2 THEN<br />
&nbsp; &nbsp; SWAP y3, y2<br />
&nbsp; &nbsp; SWAP x3, x2<br />
END IF<br />
</div>

</li>
<li><p>Interpolate A to B</p>

<div class="code">
dx1 = x2 - x1 <br />
dy1 = y2 - y1 <br />
IF dy1 &lt;&gt; 0 THEN <br />
&nbsp; &nbsp; Xstep1! = dx1 / dy1 <br />
ELSE<br />
&nbsp; &nbsp; Xstep1! = 0<br />
END IF<br />
</div>

</li>
<li><p>Interpolate B to C</p>

<div class="code">
dx2 = x3 - x2 <br />
dy2 = y3 - y2<br />
IF dy2 &lt;&gt; 0 THEN<br />
&nbsp; &nbsp; Xstep2! = dx2 / dy2<br />
ELSE<br />
&nbsp; &nbsp; Xstep2! = 0<br />
END IF<br />
</div>

</li>
<li><p>Interpolate A to C</p>

<div class="code">
dx3 = x1 - x3<br />
dy3 = y1 - y3<br />
IF dy3 &lt;&gt; 0 THEN<br />
&nbsp; &nbsp; Xstep3! = dx3 / dy3<br />
ELSE<br />
&nbsp; &nbsp; Xstep3! = 0<br />
END IF<br />
</div>

</li>
<li><p>Draw Top Part</p>

<div class="code">
Lx! = x1&nbsp; 'Starting coords<br />
Rx! = x1<br />
<br />
FOR y = y1 TO y2 - 1<br />
&nbsp; &nbsp; LINE (Lx!, y)-(Rx!, y), clr<br />
&nbsp; &nbsp; Lx! = Lx! + Xstep1!&nbsp; &nbsp;'increment derivatives<br />
&nbsp; &nbsp; Rx! = Rx! + Xstep3!<br />
NEXT y<br />
</div>

</li>
<li><p>Draw Lower Part</p>

<div class="code">
Lx! = x2<br />
FOR y = y2 TO y3<br />
&nbsp; &nbsp; LINE (Lx!, y)-(Rx!, y), clr<br />
&nbsp; &nbsp; Lx! = Lx! + delta2!<br />
&nbsp; &nbsp; Rx! = Rx! + delta3!<br />
NEXT y<br />
</div>

</li></ol>
</li></ol>

<p>Here's an example file:<br />
<a href="flattri.bas" target="_blank">flattri.bas</a></p>

</li>
<b><li><p>Gouraud Filled</p></b>

<p>There is not that much difference between the flat triangle and the gouraud triangle. In the calling sub, instead of
just the 3 coodinates, there are 3 paramenters more. Namely: c1,c2,c3.  They are the colors we could want to interpolate
between vertices. And since you know how to interpolate already, it would not be a problem. :*)</p>

<p>First we need a horizontal line routine that draws with interpolated colors. Here's the code. It's self explanatory.</p>

<p><i>*dc! is the ColorStep(Like the Xsteps)</i></p>

<p>QB code:</p>

<div class="code">
HlineG (x1,x2,y,c1,c2)<br />
<br />
&nbsp; &nbsp; dc! = (c2 - c1)/ (x2 - x1)<br />
&nbsp; &nbsp; c! = c1<br />
&nbsp; &nbsp; FOR x = x1 TO x2<br />
&nbsp; &nbsp; &nbsp; &nbsp; PSET (x, y) , int(c!)<br />
&nbsp; &nbsp; &nbsp; &nbsp; c! = c! + dc!<br />
&nbsp; &nbsp; NEXT x<br />
</div>

<p>Now that we have a horizontal gouraud line, we will modify some code into our flat filler to make it a gouraud filler.
I won't give you the whole code, but some important snippets.</p>

<ol>
<li><p>In the sorting stuff: (You have to do this to all the IF's.</p>

<div class="code">
IF y2 &lt; y1 THEN <br />
&nbsp; &nbsp; SWAP y1, y2<br />
&nbsp; &nbsp; SWAP x1, x2<br />
&nbsp; &nbsp; SWAP c1, c2<br />
END IF<br />
</div>

</li>
<li><p>Interpolate A to B; c1 to c2. do this to all vertices.</p>

<div class="code">
dx1 = x2 - x1 <br />
dy1 = y2 - y1 <br />
dc1 = c2 - c1<br />
IF dy1 &lt;&gt; 0 THEN <br />
&nbsp; &nbsp; Xstep1! = dx1 / dy1 <br />
&nbsp; &nbsp; Cstep1! = dc1 / dy1<br />
ELSE<br />
&nbsp; &nbsp; Xstep1! = 0<br />
&nbsp; &nbsp; Cstep1! = 0<br />
END IF<br />
</div>

</li>
<li><p>Draw Top Part</p>

<div class="code">
Lx! = x1 'Starting coords<br />
Rx! = x1<br />
Lc! = c1 'Starting colors<br />
Rc! = c1<br />
<br />
FOR y = y1 TO y2 - 1<br />
&nbsp; &nbsp; HlineG Lx!, Rx!, y, Lc!, Rc!<br />
&nbsp; &nbsp; Lx! = Lx! + Xstep1! <br />
&nbsp; &nbsp; Rx! = Rx! + Xstep3!<br />
&nbsp; &nbsp; Lc! = Lc! + Cstep1! 'Colors<br />
&nbsp; &nbsp; Rc! = Rc! + Cstep3!<br />
NEXT y<br />
</div>

</li>
</ol>

<p>It's that easy!  You have to interpolate just 3 more values! Here's the complete example file:<br />
<a href="gourtri.bas" target="_blank">gourtri.bas</a></p>

</li>
<b><li></p>Affine Texture Mapped</p></b>

<p>Again, there is not much difference between the previous 2 triangle routines from this. Affine texturemapping also
involves the same algo as that of the flat filler. That is, Linear interpolation.  That's probably why it doesn't look
good. :*(  But it's fast. :*).  If in the gouraud filler you need to interpolate between 3 colors, you need to interpolate
between 3 U and 3 V texture coordinates in the affine mapper. That's 6 values in all. In fact, it's almost the same as
gouraud filler!</p>

<p align="center"><img src="textmap.png"></p>

<p>Now we have to modify our Gouraud Horizontal line routine to a textured line routine.</p>

<p><i>*This assumes that the texture size is square and a power of 2. Ie. 4*4, 16*16, 128*128,etc. And is used to prevent from reading pixels outside the texture.<br />
*The texture mapper assumes a QB GET/PUT compatible image. Array(1) = width*8; Array(2) = Height; Array(3) = 2 pixels.<br />
*HlineT also assumes that a DEF SEG = Varseg(Array(0)) has been issued prior to the call. TOFF is the Offset of the image in multiple image arrays. ie: TOFF = VARPTR(Array(0))<br />
*TsizeMinus1 is Texturesize -1.</i></p>

<p>QB code:</p>
<div class="code">
HlineT (x1,x2,y,u1,u2,v1,v2,Tsize)<br />
<br />
&nbsp; &nbsp; du! = (u2 - u1)/ (x2 - x1)<br />
&nbsp; &nbsp; dv! = (v2 - v1)/ (x2 - x1)<br />
&nbsp; &nbsp; u! = u1<br />
&nbsp; &nbsp; v! = v1<br />
&nbsp; &nbsp; TsizeMinus1 = Tsize - 1<br />
<br />
&nbsp; &nbsp; FOR x = x1 TO x2<br />
&nbsp; &nbsp; &nbsp; &nbsp; 'get pixel off the texture using<br />
&nbsp; &nbsp; &nbsp; &nbsp; 'direct memory read. The (+4 + TOFF) <br />
&nbsp; &nbsp; &nbsp; &nbsp; 'is used to compensate for image<br />
&nbsp; &nbsp; &nbsp; &nbsp; 'offsetting.<br />
&nbsp; &nbsp; &nbsp; &nbsp; Tu = u! AND TsizeMinus1<br />
&nbsp; &nbsp; &nbsp; &nbsp; Tv = v! AND TsizeMinus1<br />
&nbsp; &nbsp; &nbsp; &nbsp; Texel = Peek(Tu*Tsize + Tv + 4 + TOFF)<br />
&nbsp; &nbsp; &nbsp; &nbsp; PSET (x, y) , Texel<br />
&nbsp; &nbsp; &nbsp; &nbsp; u! = u! + du!<br />
&nbsp; &nbsp; &nbsp; &nbsp; v! = v! + dv!<br />
&nbsp; &nbsp; NEXT x<br />
</div>

<p>Now we have to modify the rasterrizer to support U and V coords. All we have to do is interpolate between all the
coords and we're good to go.</p>

<ol>
<li><p>In the sorting stuff: (You have to do this to all the IF's.)</p>

<div class="code">
IF y2 &lt; y1 THEN <br />
&nbsp; &nbsp; SWAP y1, y2<br />
&nbsp; &nbsp; SWAP x1, x2<br />
&nbsp; &nbsp; SWAP u1, u2<br />
&nbsp; &nbsp; SWAP v1, v2<br />
END IF<br />
</div>

</li>
<li><p>Interpolate A to B; u1 to u2; v1 to v2. Do this to all vertices.</p>

<div class="code">
dx1 = x2 - x1 <br />
dy1 = y2 - y1 <br />
du1 = u2 - u1<br />
dv1 = v2 - v1<br />
IF dy1 &lt;&gt; 0 THEN <br />
&nbsp; &nbsp; Xstep1! = dx1 / dy1 <br />
&nbsp; &nbsp; Ustep1! = du1 / dy1<br />
&nbsp; &nbsp; Vstep1! = dv1 / dy1<br />
ELSE<br />
&nbsp; &nbsp; Xstep1! = 0<br />
&nbsp; &nbsp; Ustep1! = 0<br />
&nbsp; &nbsp; Vstep1! = 0<br />
END IF<br />
</div>

</li>
<li><p>Draw Top Part</p>

<div class="code">
Lx! = x1 'Starting coords<br />
Rx! = x1<br />
Lu! = u1 'Starting U<br />
Ru! = u1<br />
Lv! = v1 'Starting V<br />
Rv! = v1<br />
<br />
FOR y = y1 TO y2 - 1<br />
&nbsp; &nbsp; HlineT Lx!, Rx!, y, Lu!, Ru!, Lv!, Rv!<br />
&nbsp; &nbsp; Lx! = Lx! + Xstep1! <br />
&nbsp; &nbsp; Rx! = Rx! + Xstep3!<br />
&nbsp; &nbsp; Lu! = Lu! + Ustep1! 'U<br />
&nbsp; &nbsp; Ru! = Ru! + Ustep3!<br />
&nbsp; &nbsp; Lv! = Lv! + Vstep1! 'V<br />
&nbsp; &nbsp; Rv! = Rv! + Vstep3!<br />
NEXT y<br />
</div>

<p>Here's the example demo for you to learn from. Be sure to check the algo as it uses fixpoint math to speed things up
quite a bit. :*)<br />
<a href="texttri.bas" target="_blank">texttri.bas</a></p>

</li></ol>
</li></ol>
</li></ol>

<h3><li>Shading and Mapping Techniques</h3>

<ol>
<h3><li>Lambert Shading</h3>

<p>So you want your cube filled and lightsourced, but don't know how to? The answer is Lambert Shading. And what
does Lambert shading use? The NORMAL. Yes, it's the cross-product thingy I was writing about. How do we use the
normal you say. First, you have a filled cube composed of triangles (Polys), now we define a vector orthogonal to
that plane (Yep, the Normal) sticking out.</p>

<p>How do we calculate normals? Easy, use the cross product!</p>

<p>Pseudo Code:</p>

<div class="code">
1. For each poly...<br />
2. Get poly's x, y and z coords<br />
3. Define vectors from 3 coords<br />
4. Get the cross-product(our normal to a plane)<br />
5. Normalize your normal<br />
</div>

<p>QB code:</p>
<div class="code">
FOR i = 1 TO UBOUND(Poly)<br />
&nbsp; &nbsp; P1 = Poly(i).P1&nbsp; &nbsp; &nbsp; 'get poly vertex<br />
&nbsp; &nbsp; P2 = Poly(i).P2<br />
&nbsp; &nbsp; P3 = Poly(i).P3<br />
&nbsp; &nbsp; x1 = Model(P1).x&nbsp; &nbsp; &nbsp;'get coords<br />
&nbsp; &nbsp; x2 = Model(P2).x<br />
&nbsp; &nbsp; x3 = Model(P3).x<br />
&nbsp; &nbsp; y1 = Model(P1).y<br />
&nbsp; &nbsp; y2 = Model(P2).y<br />
&nbsp; &nbsp; y3 = Model(P3).y<br />
&nbsp; &nbsp; Z1 = Model(P1).z<br />
&nbsp; &nbsp; Z2 = Model(P2).z<br />
&nbsp; &nbsp; Z3 = Model(P3).z<br />
<br />
&nbsp; &nbsp; ax! = x2 - x1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'derive vectors<br />
&nbsp; &nbsp; bx! = x3 - x2<br />
&nbsp; &nbsp; ay! = y2 - y1<br />
&nbsp; &nbsp; by! = y3 - y2<br />
&nbsp; &nbsp; az! = Z2 - Z1<br />
&nbsp; &nbsp; bz! = Z3 - Z2<br />
<br />
&nbsp; &nbsp; 'Cross product<br />
&nbsp; &nbsp; xnormal! = ay! * bz! - az! * by!<br />
&nbsp; &nbsp; ynormal! = az! * bx! - ax! * bz!<br />
&nbsp; &nbsp; znormal! = ax! * by! - ay! * bx!<br />
<br />
&nbsp; &nbsp; 'Normalize<br />
&nbsp; &nbsp; Mag! = SQR(xnormal! ^ 2 + ynormal! ^ 2 + znormal! ^ 2)<br />
&nbsp; &nbsp; IF Mag! &lt;&gt; 0 THEN<br />
&nbsp; &nbsp; &nbsp; &nbsp; xnormal! = xnormal! / Mag!<br />
&nbsp; &nbsp; &nbsp; &nbsp; ynormal! = ynormal! / Mag!<br />
&nbsp; &nbsp; &nbsp; &nbsp; znormal! = znormal! / Mag!<br />
&nbsp; &nbsp; END IF<br />
<br />
<br />
&nbsp; &nbsp; v(i).x = xnormal! 'this is our face normal<br />
&nbsp; &nbsp; v(i).y = ynormal!<br />
&nbsp; &nbsp; v(i).z = znormal!<br />
<br />
NEXT i<br />
</div>

<p><i>Q: "You expect me to do this is real-time?!!!" "That square-root alone would make my renders slow as hell!!"<br />
A: No. You only need to do this when setting up your renders. ie. Only do this once, and at the top of your proggie.</i></p>

<p>Now that we have our normal, we define a light source. Your light source is also a vector. Be sure that both vectors
are normalized.</p>

<p>ie.</p>

<div class="code">
Light.x\<br />
Light.y &gt; The light vector <br />
Light.z/<br />
<br />
Polynormal.x\<br />
Polynormal.y &gt; The Plane normal<br />
Polynormal.z/<br />
</div>

<p align="center"><img src="dotproduct.png"></p>

<p>The angle in the pic is the <b>incident angle</b> between the light and the plane normal. The <b>angle is inversely
proportional to the intensity of light.</b> So the lesser the angle, the more intense the light. But how do we get the
intensity? Fortunately, there is an easy way to calculate the light.  All we have to do is get the Dot product between
these vectors!!! Since the dot returns a scalar value ,Cosine(angle), we can get the brightness factor by just
multiplying the Dot product by the color range!!! In screen 13: Dot*255.</p>

<div class="code">
nx! = PolyNormal.x<br />
ny! = PolyNormal.y<br />
nz! = PolyNormal.z<br />
lx! = LightNormal.x<br />
ly! = LightNormal.y<br />
lz! = LightNormal.z<br />
Dot! = (nx! * lx!) + (ny! * ly!) + (nz! * lz!)<br />
IF Dot! &lt; 0 THEN Dot! = 0<br />
&nbsp; &nbsp; Clr = Dot! * 255<br />
&nbsp; &nbsp; FlatTri x1, y1, x2, y2, x3, y3, Clr<br />
END IF<br />
</div>

<p>Here's an example file in action:<br />
<a href="lambert.bas" target="_blank">lambert.bas</a></p>

</li>
<h3><li>Gouraud Shading</h3>

<p>After the lambert shading, we progress into gouraud shading.</p>

<p>Q: But how do we find a normal to a point?<br />
A: You can't. There is no normal to a point. The cross-product is exclusive to planes(3d) so you just can't.
You don't have to worry though, as there are ways around this problem.</p>

<p>What we need to do is to find adjacent faces that the vertex is located and average their <b>face normals</b>. It's an
approximation but it works!</p>

<p>Let: V()= Face normal; V2() vertexnormal</p>

<div class="code">
FOR i = 1 TO Numvertex<br />
&nbsp; &nbsp; xnormal! = 0<br />
&nbsp; &nbsp; ynormal! = 0<br />
&nbsp; &nbsp; znormal! = 0<br />
&nbsp; &nbsp; FaceFound = 0<br />
<br />
&nbsp; &nbsp; FOR j = 0 TO UBOUND(Poly)<br />
&nbsp; &nbsp; &nbsp; &nbsp; IF Poly(j).P1 = i OR Poly(j).P2 = i OR Poly(j).P3 = i THEN<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xnormal! = xnormal! + v(j).x<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ynormal! = ynormal! + v(j).y<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; znormal! = znormal! + v(j).z<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FaceFound = FaceFound + 1&nbsp; &nbsp; &nbsp; &nbsp; 'Face adjacent<br />
&nbsp; &nbsp; &nbsp; &nbsp; END IF<br />
&nbsp; &nbsp; NEXT j<br />
<br />
&nbsp; &nbsp; xnormal! = xnormal! / FaceFound<br />
&nbsp; &nbsp; ynormal! = ynormal! / FaceFound<br />
&nbsp; &nbsp; znormal! = znormal! / FaceFound<br />
&nbsp; &nbsp; v2(i).x = xnormal!&nbsp; &nbsp; &nbsp; &nbsp; 'Final vertex normal<br />
&nbsp; &nbsp; v2(i).y = ynormal!<br />
&nbsp; &nbsp; v2(i).z = znormal!<br />
NEXT i<br />
</div>

<p>Now that you have calculated the vertex normals, you only have to pass the rotated vertex normals into our gouraud
filler!!! ie. Get the dot product between the rotated vertex normals and multiply it with the color range. The product
is your color coordinates.</p>

<div class="code">
IF znormal &lt; 0 THEN<br />
&nbsp; &nbsp; nx1! = CubeVTXNormal2(Poly(i).P1).X 'Vertex1<br />
&nbsp; &nbsp; ny1! = CubeVTXNormal2(Poly(i).P1).Y<br />
&nbsp; &nbsp; nz1! = CubeVTXNormal2(Poly(i).P1).Z<br />
&nbsp; &nbsp; nx2! = CubeVTXNormal2(Poly(i).P2).X 'Vertex2<br />
&nbsp; &nbsp; ny2! = CubeVTXNormal2(Poly(i).P2).Y<br />
&nbsp; &nbsp; nz2! = CubeVTXNormal2(Poly(i).P2).Z<br />
&nbsp; &nbsp; nx3! = CubeVTXNormal2(Poly(i).P3).X 'Vertex3<br />
&nbsp; &nbsp; ny3! = CubeVTXNormal2(Poly(i).P3).Y<br />
&nbsp; &nbsp; nz3! = CubeVTXNormal2(Poly(i).P3).Z<br />
<br />
&nbsp; &nbsp; lx! = LightNormal.X<br />
&nbsp; &nbsp; ly! = LightNormal.Y<br />
&nbsp; &nbsp; lz! = LightNormal.Z<br />
<br />
&nbsp; &nbsp; 'Calculate dot-products of vertex normals<br />
&nbsp; &nbsp; Dot1! = (nx1! * lx!) + (ny1! * ly!) + (nz1! * lz!)<br />
&nbsp; &nbsp; IF Dot1! &lt; 0 THEN 'Limit<br />
&nbsp; &nbsp; &nbsp; &nbsp; Dot1! = 0<br />
&nbsp; &nbsp; ELSEIF Dot1! &gt; 1 THEN<br />
&nbsp; &nbsp; &nbsp; &nbsp; Dot1! = 1<br />
&nbsp; &nbsp; END IF<br />
&nbsp; &nbsp; Dot2! = (nx2! * lx!) + (ny2! * ly!) + (nz2! * lz!)<br />
&nbsp; &nbsp; IF Dot2! &lt; 0 THEN<br />
&nbsp; &nbsp; &nbsp; &nbsp; Dot2! = 0<br />
&nbsp; &nbsp; ELSEIF Dot2! &gt; 1 THEN<br />
&nbsp; &nbsp; &nbsp; &nbsp; Dot2! = 1<br />
&nbsp; &nbsp; END IF<br />
&nbsp; &nbsp; Dot3! = (nx3! * lx!) + (ny3! * ly!) + (nz3! * lz!)<br />
&nbsp; &nbsp; IF Dot3! &lt; 0 THEN<br />
&nbsp; &nbsp; &nbsp; &nbsp; Dot3! = 0<br />
&nbsp; &nbsp; ELSEIF Dot3! &gt; 1 THEN<br />
&nbsp; &nbsp; &nbsp; &nbsp; Dot3! = 1<br />
&nbsp; &nbsp; END IF<br />
<br />
&nbsp; &nbsp; 'multiply by color range<br />
&nbsp; &nbsp; clr1 = Dot1! * 255<br />
&nbsp; &nbsp; clr2 = Dot2! * 255<br />
&nbsp; &nbsp; clr3 = Dot3! * 255<br />
<br />
&nbsp; &nbsp; GouraudTri x1, y1, clr1, x2, y2, clr2, x3, y3, clr3<br />
END IF<br />
</div>

<p>Here's and example file:<br />
<a href="gouraud.bas" target="_blank">gouraud.bas</a></p>

</li>
<h3><li>Phong Shading (Fake)</h3>

<p>Phong shading is a shading technique which utilizes diffuse, ambient and specular lighting. The only way to do
Real phong shading is on a per-pixel basis. Here's the equation:</p>

<div class="code">
Intensity=Ambient + Diffuse * (L • N) + Specular * (R • V)^Ns<br />
</div>

<p>Where:</p>

<p><b>Ambient</b> = This is the light intensity that the objects reflect upon the environment.  It reaches even in shadows.</p>

<p><b>Diffuse</b> = Light that scatters in all direction</p>

<p><b>Specular</b> = Light intensity that is dependent on the angle between your eye vector and the reflection vector.  As the angle between them increases, the less intense it is.</p>

<p><b>L.N</b> = The dot product of the Light(L) vector and the Surface Normal(N)</p>

<p><b>R.V</b> = The dot product of the Reflection(R) and the View(V) vector.</p>

<p><b>Ns</b> = is the specular intensity parameter, the greater the value, the more intense the specular light is.</p>

<p><i>*L.N could be substututed to R.V which makes our equation:</i></p>

<div class="code">
Intensity=Ambient + Diffuse * (L • N) + Specular * (L • N)^Ns<br />
</div>

<p>Technically, <b>this should be done for every pixel of the polygon</b>. But since we are making real-time engines and
using QB, this is almost an impossibilty. :*(</p>

<p>Fortunately, there are some ways around this. Not as good looking, but works nonetheless. One way is to make a phong
texture and use environment mapping to simulate light. Another way is to modify your palette and use gouraud filler to do
the job. How do we do it then? Simple! Apply the equation to the RGB values of your palette!!!</p>

<p>First we need to calculate the angles for every, color index in our pal. We do this by interpolating our Normals'
angle (90 degrees) and Light vectors' angle with the color range.</p>

<p>Pseudo Code:</p>

<div class="code">
Range = 255 - 0&nbsp; &nbsp; &nbsp; &nbsp; 'screen 13<br />
<br />
Angle! = PI / 2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'90 degrees<br />
<br />
Anglestep! = Angle!/Range&nbsp; 'interpolate<br />
<br />
For Every color index...<br />
<br />
&nbsp; &nbsp; Dot! = Cos(Angle!)<br />
<br />
&nbsp; &nbsp; '''Apply equation<br />
<br />
&nbsp; &nbsp; 'RED<br />
<br />
&nbsp; &nbsp; Diffuse! = RedDiffuse * Dot! <br />
<br />
&nbsp; &nbsp; Specular! = RedSpecular + (Dot! ^Ns)<br />
<br />
&nbsp; &nbsp; Red% = RedAmbient! + Diffuse! + Specular!<br />
<br />
&nbsp; &nbsp; 'GREEN<br />
<br />
&nbsp; &nbsp; Diffuse! = GreenDiffuse * Dot! <br />
<br />
&nbsp; &nbsp; Specular! = GreenSpecular + (Dot! ^Ns)<br />
<br />
&nbsp; &nbsp; Green% = GreenAmbient! + Diffuse! + Specular!<br />
<br />
&nbsp; &nbsp; 'BLUE<br />
<br />
&nbsp; &nbsp; Diffuse! = BlueDiffuse * Dot! <br />
<br />
&nbsp; &nbsp; Specular! = BlueSpecular + (Dot! ^Ns)<br />
<br />
&nbsp; &nbsp; Red% = BlueAmbient! + Diffuse! + Specular!<br />
<br />
&nbsp; &nbsp; WriteRGB(Red%,Green%,Blue%,ColorIndex)<br />
<br />
&nbsp; Angle! = AngleStep!<br />
<br />
Loop until maxcolor&nbsp; <br />
</div>

<p><i>* This idea came from a Cosmox 3d demo by Bobby 3999. Thanks a bunch!</i></p>

<p>Here's an example file:<br />
<a href="phong.bas" target="_blank">phong.bas</a></p>

</li>
<h3><li>Texture Mapping</h3>

<p>Texture mapping is a type of fill that uses a texture (image) to fill a polygon. Unlike our previous fills, this one
"plasters" an image (the texture) on your cube. I'll start by explaining what are those U and V coordinates in the Affine
mapper part of the article. The U and V coordinates are the Horizontal and vertical coordinates of the bitmap (our texture).
How do we calculate those coordinates? Fortunately, most 3d modelelers already do this for us automatically. :*).</p>

<p>However, if you like to make your models the math way, that is generating them mathematically, you have to calculate
them by yourself. What I do is divide the quad into two triangles and blast the texture coordinates on loadup. Lookat the
diagram to see what I mean.</p>

<p><i>*Textsize is the width or height of the bitmap</i></p>

<div class="code">
FOR j = 1 TO UBOUND(Poly)<br />
&nbsp; &nbsp; u1 = 0<br />
&nbsp; &nbsp; v1 = 0<br />
&nbsp; &nbsp; u2 = TextSize%<br />
&nbsp; &nbsp; v2 = TextSize%<br />
&nbsp; &nbsp; u3 = TextSize%<br />
&nbsp; &nbsp; v3 = 0<br />
&nbsp; &nbsp; Poly(j).u1 = u1<br />
&nbsp; &nbsp; Poly(j).v1 = v1<br />
&nbsp; &nbsp; Poly(j).u2 = u2<br />
&nbsp; &nbsp; Poly(j).v2 = v2<br />
&nbsp; &nbsp; Poly(j).u3 = u3<br />
&nbsp; &nbsp; Poly(j).v3 = v3<br />
&nbsp; &nbsp; j = j + 1<br />
&nbsp; &nbsp; u1 = 0<br />
&nbsp; &nbsp; v1 = 0<br />
&nbsp; &nbsp; u2 = 0<br />
&nbsp; &nbsp; v2 = TextSize%<br />
&nbsp; &nbsp; u3 = TextSize%<br />
&nbsp; &nbsp; v3 = TextSize%<br />
&nbsp; &nbsp; Poly(j).u1 = u1<br />
&nbsp; &nbsp; Poly(j).v1 = v1<br />
&nbsp; &nbsp; Poly(j).u2 = u2<br />
&nbsp; &nbsp; Poly(j).v2 = v2<br />
&nbsp; &nbsp; Poly(j).u3 = u3<br />
&nbsp; &nbsp; Poly(j).v3 = v3<br />
NEXT j<br />
</div>

<p>After loading the textures, you just call the TextureTri sub passing the right parameters and it would texture your
model for you. It's a good idea to make a 3d map editor that let's you pass texture coordinates, instead of calculating
it on loadup. Here's a code snippet to draw a textured poly.</p>

<div class="code">
u1 = Poly(i).u1 'Texture Coords<br />
v1 = Poly(i).v1<br />
u2 = Poly(i).u2<br />
v2 = Poly(i).v2<br />
u3 = Poly(i).u3<br />
v3 = Poly(i).v3<br />
TextureTri x1, y1, u1, v1, x2, y2, u2, v2, x3, y3, u3, v3, TSEG%, TOFF%<br />
</div>

<p><i>*Tseg% and Toff% are the Segment and Offset of the Bitmap.</i></p>

<p>Here's an example file:<br />
<a href="texture.bas" target="_blank">texture.bas</a></p>

</li>
<h3><li>Environment Mapping</h3>

<p>Environment mapping (also called Reflection Mapping) is a way to display a model as if it's reflecting a surface in
front of it. Your model looks like a warped-up mirror! It looks so cool, I jumped off my chair when I first made one. :*)
We texture our model using the texture mapper passing a vertex-normal modified texture coordinate. What does it mean?
It means we calculate our texture coordinate using our vertex normals!</p>

<p>Here's the formula:</p>

<div class="code">
TextureCoord = Wid/2+Vertexnormal*Hie/2<br />
</div>

<p>Where:</p>

<p>Wid = Width of the bitmap<br />
Hei = Height of the bitmap</p>

<p>Now, assuming your texture has the same width and height:</p>

<div class="code">
Tdiv2! = Textsize% / 2<br />
FOR i = 1 TO UBOUND(Poly)<br />
&nbsp; &nbsp; u1! = Tdiv2! + v(Poly(i).P1).x * Tdiv2! 'Vertex1<br />
&nbsp; &nbsp; v1! = Tdiv2! + v(Poly(i).P1).y * Tdiv2!<br />
&nbsp; &nbsp; u2! = Tdiv2! + v(Poly(i).P2).x * Tdiv2! 'Vertex2<br />
&nbsp; &nbsp; v2! = Tdiv2! + v(Poly(i).P2).y * Tdiv2!<br />
&nbsp; &nbsp; u3! = Tdiv2! + v(Poly(i).P3).x * Tdiv2! 'Vertex3<br />
&nbsp; &nbsp; v3! = Tdiv2! + v(Poly(i).P3).y * Tdiv2!<br />
&nbsp; &nbsp; Poly(i).u1 = u1!<br />
&nbsp; &nbsp; Poly(i).v1 = v1!<br />
&nbsp; &nbsp; Poly(i).u2 = u2!<br />
&nbsp; &nbsp; Poly(i).v2 = v2!<br />
&nbsp; &nbsp; Poly(i).u3 = u3!<br />
&nbsp; &nbsp; Poly(i).v3 = v3!<br />
NEXT i<br />
</div>

<p>After setting up the vertex normals and the texture coordinates, inside your rasterizing loop:</p>

<ol>
<li style="margin-bottom:0em;">Rotate Vertex normals</li>
<li style="margin-bottom:0em;">Calculate texture coordinates</li>
<li style="margin-bottom:0em;">Draw model</li>
</ol>

<p>That's it! Your own environment mapped rotating object. ;*)</p>

<p>Here's a demo:<br />
<a href="envmap.bas" target="_blank">envmap.bas</a></p>

<p>Another one that simulates textures with phong shading using a phongmapped texture.<br />
<a href="phong2.bas" target="_blank">phong2.bas</a></p>

</li>
<h3><li>Shading in multicolor</h3>

<p>Our previous shading techniques, Lambert, gouraud, and phong, looks good but you are limited to a single gradient. Not
a good fact if you want to use colors. But using colors in screen 13 limits you to flat shading. I bet you would want a
gouraud or phong shaded colored polygons right? Well, lo and behold! There is a little way around this problem. :*)</p>

<p>We use a subdivided gradient palette! A subdivided gradient palette divides your whole palette into gradients of colors
limited to its subdivision. Here's a little palette I made using data statements and the gradcolor sub.</p>

<p align="center"><img src="gradient.png"></p>

<p>If you look closely, each line starts with a dark color and progresses to an intense color. And if you understood how
our fillers work, you'll get the idea of modifying the fillers to work with this pal. Okay, since I'm feeling good today,
I'll just give it to you. After you calculated the Dot-product between the light and poly normals:</p>

<p><i>*This assumes a 16 color gradient palette. You could make it 32 or 64 if you want. Of course if you make it 32, you
should multiply by 32 instead of 16. :*)</i></p>

<p>QB code:</p>

<div class="code">
Clr1 = (Dot1! * 16) + Poly(j).Clr '16 color grad<br />
Clr2 = (Dot2! * 16) + Poly(j).Clr<br />
Clr3 = (Dot3! * 16) + Poly(j).Clr<br />
<br />
GouraudTri x1, y1, Clr1, x2, y2, Clr2, x3, y3, Clr3<br />
</div>

<p>Here's an example:<br />
<a href="3dcolors.bas" target="_blank">3dcolors.bas</a></p>

</li>
<h3><li>Translucency</h3>

<p>A lot of people have asked me about the algo behind my translucent teapot in <b>Mono and Disco</b>. It's not that hard
once you know how to make a translucent pixel. This is not really TRUE translucency, It's a gradient-based blending
algorithm. You make a 16 color gradient palette and apply it to the color range (Same grad above. :*) ).</p>

<p>Pseudo Code:</p>

<div class="code">
For Every pixel in the poly...<br />
<br />
TempC = PolyPixel and 15<br />
<br />
BaseColor = PolyPixel - TempC<br />
<br />
DestC = Color_Behind_Poly_Pixel and 15<br />
<br />
C =&nbsp; (TempC + DestC)/2<br />
<br />
C = C + Basecolor<br />
<br />
Pset(x,y),C<br />
</div>

<p>What this does for every pixel is to average the polygons color with the color behind it(the screen or buffer) and
add it to the basecolor. The basecolor is the starting color for each gradient. Ie. (0-15): 0 is the base color; (16 to 31):
16 is the base color. Hence the AND 15. Of course, you can make it a 32 color gradient and AND it by 31. :*)</p>

<p>Here's a little demo of Box translucency I made for my Bro. Hex. ;*)<br />
<a href="transhex.bas" target="_blank">transhex.bas</a></p>

<p>Here's the 3d translucency demo:<br />
<a href="transluc.bas" target="_blank">transluc.bas</a></p>

</li></ol>
</li></ol>

<h3>Final Words</h3>

<p>To make good models, use a 3d modeler and import it as an OBJ file as it's easy to read 3d Obj files. Lightwave3d and
Milkshape3d can import their models in the OBJ format. In fact I made a loader myself. ;*) Note that some models does not
have textures, notably, Ship.l3d, fighter.l3d, etc. The only ones with saved textures are  Cubetext, Maze2, TriforcT, and
Pacmaze2.</p>

<p>Zipped with OBJs:<br />
<a href="loadobj.zip" target="_blank">loadobj.zip</a></p>

<p>Bas File:<br />
<a href="loadl3d.bas" target="_blank">loadl3d.bas</a></p>

<p>This article is just a stepping stone for you into bigger things like Matrices, viewing systems and object handling.
I hope you learned something from this article as this took me a while to write. Making the example files felt great
though. :*) Any questions, errors in this doc, etc., you can post questions at <a href="http://forum.qbasicnews.com/" target="_blank">http://forum.qbasicnews.com/</a>.
Chances are, I would see it there.</p>

<p>Next article, I will discuss Matrices and how to use them effectively on your 3d engine. I would also discuss polygon
clipping and probably, if space permits, 3d viewing systems. So bye for now, Relsoft, signing off...</p>

<p><a href="http://rel.betterwebber.com/" target="_blank">http://rel.betterwebber.com/</a><br />
<a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#118;&#105;&#99;&#95;&#118;&#105;&#112;&#101;&#114;&#112;&#104;&#64;&#121;&#97;&#104;&#111;&#111;&#46;&#99;&#111;&#109;">&#118;&#105;&#99;&#95;&#118;&#105;&#112;&#101;&#114;&#112;&#104;&#64;&#121;&#97;&#104;&#111;&#111;&#46;&#99;&#111;&#109;</a></p>

<p><b>Credits:</b></p>

<p>God for making me a little healthier. ;*)<br />
Dr. Davidstien for all the 3d OBJs.<br />
Plasma for SetVideoSeg<br />
Biskbart for the Torus<br />
Bobby 3999 for the Phong sub<br />
CGI Joe for the original polyfillers<br />
Blitz for the things he taught me.<br />
Toshi for the occasional help</p><div class="divide"></div>
<table>
<tr><td align="right"><b>Author:</b></td><td>Rel (Richard Eric M. Lope)</td></tr>
<tr><td align="right"><b>Email:</b></td><td><a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#118;&#105;&#99;&#95;&#118;&#105;&#112;&#101;&#114;&#112;&#104;&#64;&#121;&#97;&#104;&#111;&#111;&#46;&#99;&#111;&#109;">&#118;&#105;&#99;&#95;&#118;&#105;&#112;&#101;&#114;&#112;&#104;&#64;&#121;&#97;&#104;&#111;&#111;&#46;&#99;&#111;&#109;</a></a></td></tr>
<tr><td align="right"><b>Website:</b></td><td><a href="http://rel.betterwebber.com/" target="_blank">http://rel.betterwebber.com/</a></td></tr>
<tr><td align="right"><b>Released:</b></td><td>2004</td></tr>
</table>
</body>
</html>